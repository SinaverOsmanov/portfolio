{"version":3,"file":"features-animation-2d87f5d8.js","sources":["../../node_modules/framer-motion/dist/es/render/dom/motion-minimal.mjs","../../node_modules/framer-motion/dist/es/components/LazyMotion/index.mjs","../../node_modules/framer-motion/dist/es/render/dom/features-animation.mjs"],"sourcesContent":["import { createMotionProxy } from './motion-proxy.mjs';\nimport { createDomMotionConfig } from './utils/create-config.mjs';\n\n/**\n * @public\n */\nconst m = createMotionProxy(createDomMotionConfig);\n\nexport { m };\n","import * as React from 'react';\nimport { useState, useRef, useEffect } from 'react';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { loadFeatures } from '../../motion/features/load-features.mjs';\n\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimation } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimation}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimation')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction LazyMotion({ children, features, strict = false }) {\n    const [, setIsLoaded] = useState(!isLazyBundle(features));\n    const loadedRenderer = useRef(undefined);\n    /**\n     * If this is a synchronous load, load features immediately\n     */\n    if (!isLazyBundle(features)) {\n        const { renderer, ...loadedFeatures } = features;\n        loadedRenderer.current = renderer;\n        loadFeatures(loadedFeatures);\n    }\n    useEffect(() => {\n        if (isLazyBundle(features)) {\n            features().then(({ renderer, ...loadedFeatures }) => {\n                loadFeatures(loadedFeatures);\n                loadedRenderer.current = renderer;\n                setIsLoaded(true);\n            });\n        }\n    }, []);\n    return (React.createElement(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict } }, children));\n}\nfunction isLazyBundle(features) {\n    return typeof features === \"function\";\n}\n\nexport { LazyMotion };\n","import { animations } from '../../motion/features/animations.mjs';\nimport { gestureAnimations } from '../../motion/features/gestures.mjs';\nimport { createDomVisualElement } from './create-visual-element.mjs';\n\n/**\n * @public\n */\nconst domAnimation = {\n    renderer: createDomVisualElement,\n    ...animations,\n    ...gestureAnimations,\n};\n\nexport { domAnimation };\n"],"names":["m","createMotionProxy","createDomMotionConfig","LazyMotion","children","features","strict","setIsLoaded","useState","isLazyBundle","loadedRenderer","useRef","renderer","loadedFeatures","loadFeatures","useEffect","React.createElement","LazyContext","domAnimation","createDomVisualElement","animations","gestureAnimations"],"mappings":"0HAMK,MAACA,EAAIC,EAAkBC,CAAqB,ECkCjD,SAASC,EAAW,CAAE,SAAAC,EAAU,SAAAC,EAAU,OAAAC,EAAS,EAAK,EAAI,CACxD,KAAM,CAAA,CAAGC,CAAW,EAAIC,EAAAA,SAAS,CAACC,EAAaJ,CAAQ,CAAC,EAClDK,EAAiBC,SAAO,MAAS,EAIvC,GAAI,CAACF,EAAaJ,CAAQ,EAAG,CACzB,KAAM,CAAE,SAAAO,EAAU,GAAGC,CAAc,EAAKR,EACxCK,EAAe,QAAUE,EACzBE,EAAaD,CAAc,CAC9B,CACDE,OAAAA,EAAAA,UAAU,IAAM,CACRN,EAAaJ,CAAQ,GACrBA,EAAQ,EAAG,KAAK,CAAC,CAAE,SAAAO,EAAU,GAAGC,CAAc,IAAO,CACjDC,EAAaD,CAAc,EAC3BH,EAAe,QAAUE,EACzBL,EAAY,EAAI,CAChC,CAAa,CAER,EAAE,CAAE,CAAA,EACGS,gBAAoBC,EAAY,SAAU,CAAE,MAAO,CAAE,SAAUP,EAAe,QAAS,OAAAJ,EAAU,EAAEF,CAAQ,CACvH,CACA,SAASK,EAAaJ,EAAU,CAC5B,OAAO,OAAOA,GAAa,UAC/B,CCzDK,MAACa,EAAe,CACjB,SAAUC,EACV,GAAGC,EACH,GAAGC,CACP","x_google_ignoreList":[0,1,2]}